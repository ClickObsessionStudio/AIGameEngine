<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Pocket Chess (Two Players)</title><style>
  :root{--sq-light:#f0d9b5;--sq-dark:#b58863;--accent:#0a84ff;--hi:#ffe74d;--danger:#ff3b30;--bg:#111;--fg:#fff;--btn:#222;--btnfg:#fff;}
  @media (prefers-color-scheme: dark){:root{--sq-light:#b7c0ce;--sq-dark:#5a6b7a;--bg:#0b0e12;--fg:#eaeef3;--btn:#151a20;--btnfg:#eaeef3;--accent:#64a8ff;--hi:#ffd75e;--danger:#ff6b6b}}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
  header{padding:12px 12px 4px;display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  h1{font-size:18px;margin:0;flex:1}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .toolbar button{background:var(--btn);color:var(--btnfg);border:2px solid #444;border-radius:10px;padding:10px 12px;font-size:16px;min-width:44px;min-height:44px}
  .toolbar button:focus-visible{outline:3px solid var(--accent);outline-offset:2px}
  #wrap{padding:8px;display:grid;gap:10px;max-width:680px;margin:0 auto}
  #status{font-size:16px}
  #board{display:grid;grid-template-columns:repeat(8,1fr);grid-auto-rows:1fr;gap:0;border:4px solid #333;border-radius:12px;overflow:hidden;touch-action:manipulation}
  .sq{position:relative;display:flex;align-items:center;justify-content:center;font-size:10.5vw;line-height:1;aspect-ratio:1;user-select:none;border:0;background:transparent}
  @media (min-width:640px){.sq{font-size:64px}}
  .light{background:var(--sq-light)}.dark{background:var(--sq-dark)}
  .sq:focus-visible{outline:4px solid var(--accent);outline-offset:-4px}
  .sel{box-shadow:inset 0 0 0 5px var(--accent)}
  .move{background-image:radial-gradient(circle at center, rgba(0,0,0,.28) 0, rgba(0,0,0,.28) 18%, transparent 19%)}
  .capture{box-shadow:inset 0 0 0 5px rgba(255,255,255,.7)}
  .last{outline:5px solid rgba(255,255,255,.18);outline-offset:-5px}
  .check{box-shadow:inset 0 0 0 6px var(--danger)}
  .coord{position:absolute;font-size:11px;opacity:.8;color:#000;mix-blend-mode:soft-light}
  .dark .coord,.light .coord{color:#000}
  .coord.f{right:4px;bottom:2px}
  .coord.r{left:4px;top:2px}
  .piece{filter:drop-shadow(0 1px 0 rgba(0,0,0,.3))}
  #promo,#gameover{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55)}
  .modal{background:#1e1e1e;color:#fff;border-radius:12px;padding:14px;max-width:90vw}
  .modal h2{font-size:18px;margin:.2em 0 .4em}
  .choices{display:flex;gap:10px}
  .choices button{font-size:38px;min-width:64px;min-height:64px;border-radius:12px;border:2px solid #444;background:#2a2a2a;color:#fff}
  .choices button:focus-visible{outline:3px solid var(--accent)}
  .modal .row{display:flex;gap:8px;margin-top:8px}
  details{background:#151515;border-radius:10px;padding:10px;margin:0 12px 12px}
  details summary{cursor:pointer}
  .sr{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
  @media (prefers-reduced-motion: reduce){*{scroll-behavior:auto;transition:none!important}}
</style></head>
<body>
  <header>
    <h1 aria-label="Pocket Chess two players">Pocket Chess</h1>
    <div class="toolbar" role="toolbar" aria-label="Game controls">
      <button id="undo" aria-keyshortcuts="Control+Z" title="Undo (Ctrl+Z)">Undo</button>
      <button id="flip" title="Flip board">Flip</button>
      <button id="reset" title="New game and clear save">Reset</button>
    </div>
  </header>
  <div id="wrap">
    <div id="status" aria-live="polite">Loading…</div>
    <div id="board" role="grid" aria-label="Chess board"></div>
  </div>
  <div id="promo" role="dialog" aria-modal="true" aria-label="Choose promotion piece">
    <div class="modal">
      <h2>Promote pawn</h2>
      <div class="choices" id="promoChoices"></div>
      <div class="row"><button id="promoCancel">Cancel</button></div>
    </div>
  </div>
  <div id="gameover" role="dialog" aria-modal="true" aria-label="Game over">
    <div class="modal">
      <h2 id="overHead">Game Over</h2>
      <div id="overText" style="margin:.4em 0 8px"></div>
      <div class="row"><button id="newGame">New Game</button><button id="closeOver">Close</button></div>
    </div>
  </div>
  <details>
    <summary>Help & About</summary>
    <p>Two players, one device. Tap/click a piece to see legal moves, then tap a highlighted square. Keyboard: arrows move focus, Enter/Space select/move, Esc cancels, Ctrl+Z undoes.</p>
    <ul>
      <li>Full rules: legal move filtering, check, checkmate/stalemate, castling, en passant, and promotion.</li>
      <li>Flip the board to play from either side.</li>
      <li>Autosaves locally; Reset starts a fresh game and clears the save.</li>
      <li>Accessible: large tap targets, high contrast, visible focus, respects reduced motion.</li>
    </ul>
  </details>
  <div class="sr" aria-live="polite" id="live"></div>
<script>
(function(){'use strict';
const boardEl=document.getElementById('board');
const statusEl=document.getElementById('status');
const liveEl=document.getElementById('live');
const promoEl=document.getElementById('promo');
const promoChoices=document.getElementById('promoChoices');
const promoCancel=document.getElementById('promoCancel');
const overEl=document.getElementById('gameover');
const overHead=document.getElementById('overHead');
const overText=document.getElementById('overText');
const newGameBtn=document.getElementById('newGame');
const closeOverBtn=document.getElementById('closeOver');
const btnUndo=document.getElementById('undo');
const btnFlip=document.getElementById('flip');
const btnReset=document.getElementById('reset');
const PIECE={wK:'♔',wQ:'♕',wR:'♖',wB:'♗',wN:'♘',wP:'♙',bK:'♚',bQ:'♛',bR:'♜',bB:'♝',bN:'♞',bP:'♟'};
function inb(r,c){return r>=0&&r<8&&c>=0&&c<8}
function idx(r,c){return r*8+c}
function rc(i){return [i>>3,i&7]}
function alg(i){const f='abcdefgh'[i&7];const r=8-(i>>3);return f+''+r}
function name(p){const side=p[0]==='w'?'White':'Black';const t={K:'king',Q:'queen',R:'rook',B:'bishop',N:'knight',P:'pawn'}[p[1]];return side+' '+t}
function cloneState(S){return {b:S.b.slice(),t:S.t,ep:S.ep,cr:{wK:S.cr.wK,wQ:S.cr.wQ,bK:S.cr.bK,bQ:S.cr.bQ},lm:S.lm?S.lm.slice():null,over:S.over||null}}
function initBoard(){const b=new Array(64).fill(null);const back=['R','N','B','Q','K','B','N','R'];for(let c=0;c<8;c++){b[idx(0,c)]='b'+back[c];b[idx(1,c)]='bP';b[idx(6,c)]='wP';b[idx(7,c)]='w'+back[c]}return b}
function initial(){return {b:initBoard(),t:'w',ep:null,cr:{wK:true,wQ:true,bK:true,bQ:true},lm:null,over:null}}
function canStore(){try{const k='__t';localStorage.setItem(k,'1');localStorage.removeItem(k);return true}catch(e){return false}}
const storageOK=canStore();
function save(S){if(!storageOK)return;try{localStorage.setItem('pocket_chess_state',JSON.stringify(S))}catch(e){}
}
function load(){if(!storageOK)return null;try{const s=localStorage.getItem('pocket_chess_state');if(s){const obj=JSON.parse(s);if(obj&&obj.b&&obj.cr) return obj}}catch(e){}return null}
function saveFlip(){if(!storageOK)return;try{localStorage.setItem('pocket_chess_flip',flip?'1':'0')}catch(e){} }
function loadFlip(){if(!storageOK)return false;try{return localStorage.getItem('pocket_chess_flip')==='1'}catch(e){return false}}
let S=load()||initial();
let hist=[]; // undo stack
let selected=null; // board index
let legal=[]; // list of moves from selected
let flip=loadFlip();
let pendingPromo=null; // {from,to,flag}
function pieceAt(b,i){return b[i]}
function sideOf(p){return p? p[0] : null}
function other(s){return s==='w'?'b':'w'}
function isEmpty(b,i){return !b[i]}
function ray(b,i,dr,dc,side,out){let [r,c]=rc(i);while(true){r+=dr;c+=dc;if(!inb(r,c))break;const j=idx(r,c);const q=b[j];if(!q){out.push({from:i,to:j});continue}else{if(sideOf(q)!==side) out.push({from:i,to:j,capture:true});break}}}
function attacksSquare(b,side,target){ // any piece of 'side' attacks target?
  const [tr,tc]=rc(target);
  // Pawns
  const dir = side==='w'?-1:1;const pr=tr-dir; if(pr>=0&&pr<8){for(const dc of [-1,1]){const pc=tc-dc; if(pc>=0&&pc<8){const j=idx(pr,pc);const p=b[j]; if(p===side+'P') return true}}}
  // Knights
  const K=[[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];for(const [dr,dc] of K){const r=tr+dr,c=tc+dc;if(inb(r,c)){const p=b[idx(r,c)];if(p===side+'N')return true}}
  // Kings
  for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){if(dr||dc){const r=tr+dr,c=tc+dc;if(inb(r,c)){const p=b[idx(r,c)];if(p===side+'K')return true}}}
  // Sliding
  const dirs=[[1,0],[-1,0],[0,1],[0,-1]];for(const [dr,dc] of dirs){let r=tr+dr,c=tc+dc;while(inb(r,c)){const q=b[idx(r,c)];if(q){if(sideOf(q)===side && (q[1]==='R'||q[1]==='Q')) return true;break}r+=dr;c+=dc}}
  const d2=[[1,1],[1,-1],[-1,1],[-1,-1]];for(const [dr,dc] of d2){let r=tr+dr,c=tc+dc;while(inb(r,c)){const q=b[idx(r,c)];if(q){if(sideOf(q)===side && (q[1]==='B'||q[1]==='Q')) return true;break}r+=dr;c+=dc}}
  return false
}
function findKing(b,side){for(let i=0;i<64;i++){if(b[i]===side+'K')return i}return -1}
function inCheck(st,side){const k=findKing(st.b,side);if(k<0) return false;return attacksSquare(st.b,other(side),k)}
function genPseudo(st,i){const b=st.b;const p=b[i];if(!p)return[];const side=sideOf(p);const out=[];const [r,c]=rc(i);switch(p[1]){
  case 'P':{
    const dir = side==='w'?-1:1; const startRow = side==='w'?6:1; const promoRow = side==='w'?0:7;
    // forward
    const r1=r+dir; if(inb(r1,c)&&!b[idx(r1,c)]){const j=idx(r1,c); const promo=(r1===promoRow); out.push({from:i,to:j,promo}); if(r===startRow){const r2=r+2*dir; if(inb(r2,c)&&!b[idx(r2,c)]) out.push({from:i,to:idx(r2,c),dbl:true})}}
    // captures
    for(const dc of [-1,1]){const cc=c+dc;const rr=r+dir;if(inb(rr,cc)){const j=idx(rr,cc); if(b[j]&&sideOf(b[j])!==side){const promo=(rr===promoRow); out.push({from:i,to:j,capture:true,promo})}}
    // en passant
    if(st.ep!=null){const [er,ec]=rc(st.ep); if(er===r+dir && Math.abs(ec-c)===1){out.push({from:i,to:st.ep,ep:true,capture:true})}}
  }break;
  case 'N':{
    const K=[[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]];for(const [dr,dc] of K){const r2=r+dr,c2=c+dc;if(inb(r2,c2)){const j=idx(r2,c2);const q=b[j];if(!q||sideOf(q)!==side) out.push({from:i,to:j,capture:!!q})}}
  }break;
  case 'B': ray(b,i,1,1,side,out); ray(b,i,1,-1,side,out); ray(b,i,-1,1,side,out); ray(b,i,-1,-1,side,out); break;
  case 'R': ray(b,i,1,0,side,out); ray(b,i,-1,0,side,out); ray(b,i,0,1,side,out); ray(b,i,0,-1,side,out); break;
  case 'Q': ray(b,i,1,0,side,out); ray(b,i,-1,0,side,out); ray(b,i,0,1,side,out); ray(b,i,0,-1,side,out); ray(b,i,1,1,side,out); ray(b,i,1,-1,side,out); ray(b,i,-1,1,side,out); ray(b,i,-1,-1,side,out); break;
  case 'K':{
    for(let dr=-1;dr<=1;dr++)for(let dc=-1;dc<=1;dc++){if(dr||dc){const r2=r+dr,c2=c+dc;if(inb(r2,c2)){const j=idx(r2,c2);const q=b[j];if(!q||sideOf(q)!==side) out.push({from:i,to:j,capture:!!q})}}}
    // castling
    if(side==='w'&&i===60){ // e1
      if(st.cr.wK){ if(!b[61]&&!b[62]&&!inCheck(st,'w')&&!attacksSquare(b,'b',61)&&!attacksSquare(b,'b',62) && b[63]==='wR'){ out.push({from:i,to:62,castle:'K'}) } }
      if(st.cr.wQ){ if(!b[59]&&!b[58]&&!b[57]&&!inCheck(st,'w')&&!attacksSquare(b,'b',59)&&!attacksSquare(b,'b',58) && b[56]==='wR'){ out.push({from:i,to:58,castle:'Q'}) } }
    }
    if(side==='b'&&i===4){ // e8
      if(st.cr.bK){ if(!b[5]&&!b[6]&&!inCheck(st,'b')&&!attacksSquare(b,'w',5)&&!attacksSquare(b,'w',6) && b[7]==='bR'){ out.push({from:i,to:6,castle:'K'}) } }
      if(st.cr.bQ){ if(!b[3]&&!b[2]&&!b[1]&&!inCheck(st,'b')&&!attacksSquare(b,'w',3)&&!attacksSquare(b,'w',2) && b[0]==='bR'){ out.push({from:i,to:2,castle:'Q'}) } }
    }
  }break;
 }
 return out}
function apply(st, m, promoPiece){ // returns new state
  const S2=cloneState(st);const b=S2.b;const p=b[m.from];const side=sideOf(p);const opp=other(side);S2.ep=null; // clear by default
  // move piece
  b[m.from]=null; // empty from
  // en passant capture removal
  if(m.ep){const [tr,tc]=rc(m.to);const capr=side==='w'?tr+1:tr-1; b[idx(capr,tc)]=null}
  // castling rook move
  if(m.castle){ if(side==='w'){ if(m.castle==='K'){ b[63]=null; b[62]='wK'; b[61]='wR' } else { b[56]=null; b[58]='wK'; b[59]='wR' } }
                  else { if(m.castle==='K'){ b[7]=null; b[6]='bK'; b[5]='bR' } else { b[0]=null; b[2]='bK'; b[3]='bR' } }
  } else {
    // promotion or normal move
    if(m.promo){ const piece=(promoPiece||'Q'); b[m.to]=side+piece } else { b[m.to]=p }
  }
  // Update castling rights on king/rook move
  if(p===(side+'K')){ if(side==='w'){S2.cr.wK=false;S2.cr.wQ=false}else{S2.cr.bK=false;S2.cr.bQ=false} }
  if(p===(side+'R')){ if(side==='w'){ if(m.from===63) S2.cr.wK=false; if(m.from===56) S2.cr.wQ=false } else { if(m.from===7) S2.cr.bK=false; if(m.from===0) S2.cr.bQ=false } }
  // Update castling rights if rooks captured
  const capturedBefore = st.b[m.to];
  if(capturedBefore){ if(capturedBefore==='wR'){ if(m.to===63) S2.cr.wK=false; if(m.to===56) S2.cr.wQ=false }
                       if(capturedBefore==='bR'){ if(m.to===7) S2.cr.bK=false; if(m.to===0) S2.cr.bQ=false } }
  // Set en passant target if double pawn move
  if(p===(side+'P') && m.dbl){ const [fr,fc]=rc(m.from); const midr=side==='w'? fr-1 : fr+1; S2.ep=idx(midr,fc) }
  // Update last move markers
  S2.lm=[m.from,m.castle? (side==='w'?(m.castle==='K'?62:58):(m.castle==='K'?6:2)) : m.to];
  // Switch turn
  S2.t=opp;
  // Handle promotion when castling not used and promo flagged already done above
  return S2
}
function legalMovesFrom(st,i){const side=st.t;const b=st.b;const p=b[i];if(!p||sideOf(p)!==side) return [];const pseudo=genPseudo(st,i);const res=[];for(const m of pseudo){const promoNeeded = (m.promo===true);if(m.castle){ // special safety
    const tmp=apply(st,m); if(!inCheck(tmp,side)) res.push(m)
  }else{
    // try apply
    const tmp=cloneState(st); // copy
    // apply minimal to test check
    const pce=p; tmp.b[m.from]=null;
    if(m.ep){ const [tr,tc]=rc(m.to); const capr=side==='w'?tr+1:tr-1; tmp.b[idx(capr,tc)]=null }
    tmp.b[m.to]= promoNeeded? side+'Q' : pce; // assume queen for safety test
    // castling rights/ep don't affect check status
    if(!inCheck(tmp,side)) res.push(m)
  }}return res}
function allLegalMoves(st,side){const res=[];for(let i=0;i<64;i++){if(st.b[i]&&sideOf(st.b[i])===side){const tmpSt=cloneState(st);tmpSt.t=side;const ms=legalMovesFrom(tmpSt,i);if(ms.length) res.push(...ms)}}return res}
function gameStatus(st){const side=st.t;const moves=allLegalMoves(st,side);const check=inCheck(st,side);if(moves.length===0){return {over:true,check,draw:!check}}return {over:false,check}
}
function render(){boardEl.innerHTML=''; boardEl.style.pointerEvents= S.over? 'none':'auto';
  const vis=[];for(let vr=0;vr<8;vr++){for(let vc=0;vc<8;vc++){const br=flip? vr : 7-vr; const bc=flip? 7-vc : vc; vis.push(idx(br,bc))}}
  // Build squares
  let html='';for(let k=0;k<64;k++){const i=vis[k];const p=S.b[i];const [r,c]=rc(i);const dark=((r+c)%2)===1; const isSel= (selected===i); const lm=S.lm||[]; const isLast = (lm[0]===i||lm[1]===i); const iK=findKing(S,other(S.t)); // highlight only opponent's king when in check? We'll highlight current side's king when in check at their turn in status below
    const classes=['sq',dark?'dark':'light']; if(isSel) classes.push('sel'); if(isLast) classes.push('last');
    // Check highlight on side to move king
    const myKing = findKing(S,S.t); if(myKing===i && inCheck(S,S.t)) classes.push('check');
    // Legal move markers
    let isMove=false,isCap=false; for(const m of legal){if(m.to===i){ isMove=true; if(m.capture) isCap=true; break }} if(isMove) classes.push(isCap?'capture':'move');
    const coordF = (r=== (flip?7:0) ); const coordR = (c=== (flip?0:7));
    const ariaPiece = p? name(p)+' on '+alg(i) : 'Empty '+alg(i);
    html += `<button role="gridcell" aria-label="${ariaPiece}" class="${classes.join(' ')}" data-i="${i}" tabindex="0">`+ (p?`<span class="piece" aria-hidden="true">${PIECE[p]}</span>`:'') + (coordF?`<span class="coord f" aria-hidden="true">${'abcdefgh'[c]}</span>`:'') + (coordR?`<span class="coord r" aria-hidden="true">${8-r}</span>`:'') + `</button>`
  }
  boardEl.innerHTML=html;
  statusEl.textContent=(S.over? 'Game over. ' : '') + (S.t==='w'?'White':'Black') + ' to move' + (inCheck(S,S.t)? ' — Check!':'');
}
function selectSquare(i){if(S.over) return; const p=S.b[i]; if(selected===null){ if(p && sideOf(p)===S.t){ selected=i; legal=legalMovesFrom(S,i); announce(name(p)+' selected at '+alg(i)+'. '+(legal.length? legal.length+' legal moves' : 'No legal moves')); render() } }
 else { // already selected
   if(i===selected){ selected=null; legal=[]; render(); return }
   // Is i a legal destination?
   let mv=null; for(const m of legal){ if(m.to===i){ mv=m; break } }
   if(mv){ doMoveWithPossiblePromotion(mv) }
   else { // reselect if own piece
     if(p && sideOf(p)===S.t){ selected=i; legal=legalMovesFrom(S,i); render() } else { selected=null; legal=[]; render() }
   }
 }
}
function doMoveWithPossiblePromotion(m){const moving=S.b[m.from]; if(m.promo && moving && moving[1]==='P'){
  pendingPromo=m; showPromotion(sideOf(moving))
 } else { commitMove(m,null) }
}
function commitMove(m, promoPiece){ hist.push(cloneState(S)); S=apply(S,m,promoPiece); selected=null; legal=[]; save(S); const st=gameStatus(S); if(st.over){ S.over= st.draw? 'stalemate':'checkmate'; save(S); showGameOver(st.draw? 'Stalemate' : ((S.t==='w'?'Black':'White')+' wins by checkmate'), st.draw? 'No legal moves and not in check.' : (S.t==='w'?'Black':'White')+' delivered mate.')) } render(); const movetxt = (name(hist[hist.length-1].b[m.from])||'Piece')+' from '+alg(m.from)+' to '+alg(m.castle? (hist[hist.length-1].t==='w'? (m.castle==='K'?62:58):(m.castle==='K'?6:2)) : m.to) + (m.promo? ', promoted to '+(promoPiece||'Q'):'') + (inCheck(S,S.t)? '. Check!':''); announce(movetxt) }
function announce(t){liveEl.textContent=t}
function showPromotion(side){ promoChoices.innerHTML=''; const opts=['Q','R','B','N']; for(const ch of opts){ const btn=document.createElement('button'); btn.textContent=PIECE[side+ch]; btn.setAttribute('aria-label','Promote to '+name(side+ch)); btn.addEventListener('click',()=>{ hidePromotion(); if(pendingPromo){ commitMove(pendingPromo,ch); pendingPromo=null } }); promoChoices.appendChild(btn) } promoCancel.onclick=()=>{hidePromotion(); pendingPromo=null}; promoEl.style.display='flex'; setTimeout(()=>promoChoices.querySelector('button')?.focus(),0)
}
function hidePromotion(){ promoEl.style.display='none' }
function showGameOver(head, text){ overHead.textContent=head; overText.textContent=text; overEl.style.display='flex'; setTimeout(()=>newGameBtn.focus(),0) }
function hideGameOver(){ overEl.style.display='none' }
function resetGame(){ S=initial(); hist=[]; selected=null; legal=[]; pendingPromo=null; save(S); render(); announce('New game started') }
// Events
boardEl.addEventListener('click',e=>{const btn=e.target.closest('button.sq'); if(!btn)return; const i=+btn.dataset.i; selectSquare(i)});
boardEl.addEventListener('keydown',e=>{const key=e.key; const active=document.activeElement.closest('button.sq'); const vis=[];for(let vr=0;vr<8;vr++){for(let vc=0;vc<8;vc++){const br=flip? vr : 7-vr; const bc=flip? 7-vc : vc; vis.push(idx(br,bc))}}
  const curr=active? +active.dataset.i : vis[0]; let k=vis.indexOf(curr); if(key==='ArrowRight'){e.preventDefault(); if(k%8<7) k++; focusVis(k)} else if(key==='ArrowLeft'){e.preventDefault(); if(k%8>0) k--; focusVis(k)} else if(key==='ArrowUp'){e.preventDefault(); if(k>=8) k-=8; focusVis(k)} else if(key==='ArrowDown'){e.preventDefault(); if(k<56) k+=8; focusVis(k)} else if(key==='Enter'||key===' '){e.preventDefault(); selectSquare(curr)} else if(key==='Escape'){selected=null; legal=[]; render()} else if((e.ctrlKey||e.metaKey)&&key.toLowerCase()==='z'){e.preventDefault(); undo()}
  function focusVis(K){const bi=vis[K]; const el=boardEl.querySelector('[data-i="'+bi+'"]'); if(el) el.focus() }
});
btnUndo.addEventListener('click',undo); function undo(){ if(hist.length){ S=hist.pop(); selected=null; legal=[]; pendingPromo=null; save(S); render(); announce('Move undone') } }
btnFlip.addEventListener('click',()=>{ flip=!flip; saveFlip(); render(); announce('Board flipped') });
btnReset.addEventListener('click',()=>{ if(confirm('Reset game and clear saved state?')){ if(storageOK){ try{localStorage.removeItem('pocket_chess_state')}catch(e){} } resetGame() } });
newGameBtn.addEventListener('click',()=>{ hideGameOver(); resetGame() });
closeOverBtn.addEventListener('click',()=>{ hideGameOver(); render() });
window.addEventListener('keydown',e=>{ if((e.ctrlKey||e.metaKey)&&e.key.toLowerCase()==='z'){ e.preventDefault(); undo() } });
// Initial render
render();
})();
</script>
</body></html>